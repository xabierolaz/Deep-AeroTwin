He investigado los est谩ndares de la industria para sistemas de evasi贸n basados en Visi贸n por Computadora (como los usados en el DJI Mavic 3/4 Pro o el Skydio 2) y la diferencia con el LIDAR es cr铆tica:

Detecci贸n vs. Medici贸n: Las c谩maras pueden "ver" un objeto a 200m (detecci贸n 2D), pero no pueden saber su distancia exacta hasta que est谩n mucho m谩s cerca (estereoscop铆a efectiva).

LIDAR: Precisi贸n milim茅trica a 100-200m.

Visi贸n Est茅reo: El error de profundidad crece cuadr谩ticamente con la distancia. A partir de 20-40 metros, la medici贸n de distancia se vuelve muy ruidosa.

Rango Realista: Los drones comerciales de gama alta (DJI) tienen un rango de "Medici贸n Precisa" de solo 18-24 metros, aunque usan algoritmos predictivos para "detectar" hasta 200m.

Tu Configuraci贸n: Usar una detecci贸n de 80m es un excelente equilibrio para un sistema de "Grado Industrial/AI" (mejor que una c谩mara est茅reo b谩sica, simulando algoritmos modernos de Deep Learning como los que investigamos).

Aqu铆 tienes los cambios para transformar tu simulaci贸n en un escenario de Visi贸n Realista:

1. Actualizaci贸n de constants.py
Definimos par谩metros que imitan la incertidumbre 贸ptica: "Veo lejos, pero solo conf铆o en la distancia cuando estoy cerca".

Python

# --- EN constants.py ---

# ANTES (Irreal/LIDAR):
# DETECTION_RANGE_M = 300.0
# SAFETY_DISTANCE_M = 25.0

# AHORA (Visi贸n Realista Industrial):
DETECTION_RANGE_M = 80.0   # Rango efectivo de estimaci贸n de profundidad (AI/High-End Vision)
SAFETY_DISTANCE_M = 12.0   # "Muro" f铆sico. Margen de seguridad real (inspecci贸n cercana).
REACTION_DISTANCE_M = 45.0 # Distancia de decisi贸n. El "Cerebro" empieza a trazar curvas aqu铆.

# Ajuste de caducidad (La visi贸n es ruidosa, si dejas de ver algo, olv铆dalo r谩pido)
OBSTACLE_EXPIRY_S = 1.0    # Antes 2.0s
2. Actualizaci贸n de flight_controller.py
Desvinculamos la reacci贸n de la seguridad. Esto permite que el dron reaccione suavemente a 45m sin necesitar un margen de seguridad absurdo de 25m.

Python

# --- EN flight_controller.py ---

# A帽adir importaci贸n
from constants import REACTION_DISTANCE_M

# ... dentro de control_loop ...

# BUSCAR ESTA LNEA (aprox 263):
# if nearest_obs and min_dist < (SAFETY_DISTANCE_M * 2.0):

# CAMBIAR POR:
if nearest_obs and min_dist < REACTION_DISTANCE_M: 
    # Ahora reaccionamos a 45m fijos, independientemente del margen de seguridad.
3. Actualizaci贸n de vision_system.py
Ajustamos la simulaci贸n para que solo env铆e datos cuando el "sensor" tendr铆a una lectura fiable (80m).

Python

# --- EN vision_system.py ---

# Ya usa DETECTION_RANGE_M de constants.py, as铆 que al cambiar
# el archivo constants.py, este script se adapta autom谩ticamente a los 80m.
# No requiere cambios de c贸digo, solo de configuraci贸n.
 Resumen del Nuevo Comportamiento F铆sico
Con estos cambios (80m Detecci贸n, 45m Reacci贸n, 12m Seguridad):

Vuelo a Ciegas (Lejos): El dron volar谩 hacia la torre sin "verla" hasta estar a 80m. Esto genera tensi贸n realista (como un piloto real que escanea el horizonte).

Confirmaci贸n (80m -> 45m): Durante estos ~4 segundos (a 8 m/s), el sistema "trackea" el objeto.

Maniobra Suave (45m): A 45m, inicia el A*. Como el margen de seguridad es solo de 12m (no 25m), el algoritmo encontrar谩 "pasillos" mucho m谩s f谩cilmente y generar谩 curvas m谩s cerradas y eficientes.

Paso Cercano: El dron pasar谩 a unos 15-20 metros de la torre. Visualmente parecer谩 una maniobra experta, no un desv铆o temeroso.

Voy a generar los archivos actualizados con estos par谩metros "Profesionales".

Action-1: Tool Code Generation

Python

print("Writing constants.py...")
with open("constants.py", "w") as f:
    f.write("""#!/usr/bin/env python3
\"\"\"
Constantes globales del sistema PORCE.
Centraliza valores compartidos para evitar duplicados y mantener coherencia.
\"\"\"

import os

# ============================================================================
# MODO DEL SISTEMA (PIPELINE SELECTOR)
# ============================================================================
SYSTEM_MODE = os.environ.get('PORCE_SYSTEM_MODE', 'SIMULATION')
print(f"[{os.path.basename(__file__)}] SYSTEM_MODE inicializado como: {SYSTEM_MODE}")

_current_dir = os.path.dirname(os.path.abspath(__file__))
_project_root = os.path.dirname(_current_dir)

# ============================================================================
# CONSTANTES FISICAS
# ============================================================================
EARTH_RADIUS_M = 6371000

# ============================================================================
# CONFIGURACION DE RED
# ============================================================================
MAVLINK_HUB_HTTP_PORT = 8080
PORCE_HTTP_PORT = 9001
SANDU_HTTP_PORT = 9002
MAVLINK_TCP_PORT = 5761
SITL_TCP_PORT = 5760
SITL_UDP_PORT = 14551

# ============================================================================
# DISTANCIAS CRITICAS (VISION BASED - REALISTIC)
# ============================================================================
# Ajustado para simular visi贸n por computadora (m谩s ruido, menor rango que LIDAR)

SAFETY_DISTANCE_M = 12.0    # "Muro" f铆sico. Margen de seguridad real (12m es est谩ndar industrial).
REACTION_DISTANCE_M = 45.0  # Distancia de reacci贸n. Aqu铆 el A* empieza a calcular.

# ============================================================================
# GRID (Planificacion de Rutas)
# ============================================================================
GRID_CELL_SIZE_M = 10.0

# ============================================================================
# TIMEOUTS HTTP
# ============================================================================
HTTP_TIMEOUT_TELEMETRY_S = 10.0
HTTP_TIMEOUT_COMMAND_S = 10.0
HTTP_TIMEOUT_HEALTH_CHECK_S = 1.0

# ============================================================================
# ARCHIVOS DE CONFIGURACION
# ============================================================================
WAYPOINTS_FILE = 'ejea_default.waypoints'
UNREAL_BRIDGE_JSON_PATH = os.path.join(_current_dir, "logs", "unreal_state.json")

# ============================================================================
# VELOCIDADES DE NAVEGACION (m/s)
# ============================================================================
NAV_SPEED_HORIZONTAL_MS = 8.0
NAV_SPEED_UP_MS = 2.5
NAV_SPEED_DOWN_MS = 1.5

# ============================================================================
# DETECCION DE OBSTACULOS (VISION REALISTA)
# ============================================================================
# Simula un sistema de visi贸n High-End (AI Depth Estimation / Stereo)
# Rango efectivo de medici贸n fiable: ~80m (vs 300m irreal anterior)

DETECTION_RANGE_M = 80.0  

RAW_IMAGE_PATH = os.path.join(_project_root, "Unreal", "Saved", "Screenshots", "WindowsEditor", "raw_capture.png")
TERRAIN_ELEVATION_MSL = 435.0
YOLO_IMG_SIZE = 640
YOLO_CONF_THRESHOLD = 0.3
YOLO_IOU_THRESHOLD = 0.45
YOLO_LETTERBOX_PADDING = 114
YOLO_MIN_AREA = 25
YOLO_MIN_ASPECT_RATIO = 0.1
YOLO_MAX_ASPECT_RATIO = 10.0
CAMERA_WIDTH = 640
CAMERA_HEIGHT = 480
CAMERA_FOV_HORIZONTAL = 60.0
CAMERA_FOV_VERTICAL = 45.0
YOLO_SHOW_WINDOW = False
YOLO_SAVE_DETECTIONS_DIR = "detection_results"
YOLO_VISUALIZATION_HIGH_CONF = 0.7
YOLO_VISUALIZATION_MED_CONF = 0.5
SIMULATION_POLLING_INTERVAL_S = 1.0

# ============================================================================
# ESTIMACION DE DISTANCIA
# ============================================================================
USE_DISTANCE_APPROXIMATION = True
TOWER_TYPICAL_HEIGHT_M = 20.0
DISTANCE_CALIBRATION_FACTOR = 1.0

# ============================================================================
# VISUALIZACION
# ============================================================================
VISUALIZATION_PNG_INTERVAL_S = 5.0
VISUALIZATION_OUTPUT_DIR = "logs"
COLOR_PLANNED_CELL = (0.5, 0.7, 1.0)
COLOR_VISITED_CELL = (0.3, 0.8, 0.3)
COLOR_OBSTACLE_CELL = (1.0, 0.3, 0.3)
COLOR_SIMULATED_TOWER = (0.5, 0.5, 0.5)
COLOR_DETECTED_OBSTACLE = (1.0, 0.0, 0.0)
COLOR_DRONE = (0.0, 0.0, 0.0)
COLOR_GRID_LINE = (0.7, 0.7, 0.7)

# ============================================================================
# MAVLINK HUB & CONTROL
# ============================================================================
MAVLINK_DISCONNECT_TIMEOUT_S = 30
MAVLINK_LOG_RATE_LIMIT_S = 5.0
HEARTBEAT_TIMEOUT_S = 3.0
EVASION_VELOCITY_LATERAL_MS = 0.5
OBSTACLE_EXPIRY_S = 1.0  # Caducidad r谩pida para simular ruido de visi贸n
TELEMETRY_REFRESH_HZ = 10
MAVLINK_INTERVAL_HIGH_US = 100000
MAVLINK_INTERVAL_MED_US = 250000
MAVLINK_INTERVAL_LOW_US = 1000000
ARRIVAL_TOLERANCE_M = 5.5
ALTITUDE_TOLERANCE_M = 1.0
""")

print("Writing flight_controller.py...")
with open("flight_controller.py", "w") as f:
    f.write("""#!/usr/bin/env python3
\"\"\"
FLIGHT CONTROLLER (The Brain) v1.1 - REALISTIC VISION
-----------------------------------------------------
Actualizado para usar par谩metros realistas de visi贸n:
- Reacci贸n desacoplada de seguridad (REACTION_DISTANCE_M).
- M谩rgenes ajustados para evitar "enjaulamiento".
\"\"\"

import time, math, threading, sys, logging, json
from flask import Flask, request, jsonify
from pymavlink import mavutil
from porce_manager import PorcePlanner
from constants import (
    MAVLINK_HUB_HTTP_PORT,
    SITL_TCP_PORT,
    WAYPOINTS_FILE,
    NAV_SPEED_HORIZONTAL_MS,
    EARTH_RADIUS_M,
    SAFETY_DISTANCE_M,
    REACTION_DISTANCE_M, # NUEVO: Distancia de reaccion explicita
    ARRIVAL_TOLERANCE_M,
    ALTITUDE_TOLERANCE_M,
    HEARTBEAT_TIMEOUT_S,
    OBSTACLE_EXPIRY_S,
    EVASION_VELOCITY_LATERAL_MS,
    MAVLINK_INTERVAL_HIGH_US,
    MAVLINK_INTERVAL_MED_US,
    MAVLINK_INTERVAL_LOW_US
)

print(f"DEBUG: ALTITUDE_TOLERANCE_M is {ALTITUDE_TOLERANCE_M}")

WP_TOLERANCE_M = ARRIVAL_TOLERANCE_M
if 'EVASION_SPEED_MS' not in locals(): EVASION_SPEED_MS = 3.0

logging.basicConfig(level=logging.INFO, format='%(asctime)s [BRAIN] %(message)s', datefmt='%H:%M:%S')
log_werkzeug = logging.getLogger('werkzeug')
log_werkzeug.setLevel(logging.ERROR)

log = logging.getLogger(__name__)

app = Flask(__name__)

# --- ESTADO GLOBAL ---
state = {
    'telemetry': {
        'lat': 0.0, 'lon': 0.0, 'alt': 0.0,
        'roll': 0, 'pitch': 0, 'yaw': 0,
        'heading': 0,
        'armed': False,
        'mode': 'UNKNOWN',
        'last_update': 0
    },
    'home': None,
    'waypoints': [],
    'current_wp_idx': 1,
    'mission_loaded': False,
    'obstacles': [],
    'last_obstacle_update': 0,
    'evasion_active': False,
    'evasion_path': [],
    'path_index': 0,
    'takeoff_initiated': False
}

state_lock = threading.Lock()
master = None
planner = PorcePlanner()

def haversine(lat1, lon1, lat2, lon2):
    dlat, dlon = math.radians(lat2-lat1), math.radians(lon2-lon1)
    a = math.sin(dlat/2)**2 + math.cos(math.radians(lat1)) * math.cos(math.radians(lat2)) * math.sin(dlon/2)**2
    return EARTH_RADIUS_M * 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))

def load_mission():
    wps = []
    try:
        with open(WAYPOINTS_FILE, 'r') as f:
            for line in f:
                if line.startswith('QGC') or not line.strip(): continue
                parts = line.split()
                if len(parts) >= 11:
                    wps.append({
                        'seq': int(parts[0]),
                        'lat': float(parts[8]),
                        'lon': float(parts[9]),
                        'alt': float(parts[10])
                    })
        if wps:
            with state_lock:
                state['home'] = wps[0]
                state['waypoints'] = wps
                state['mission_loaded'] = True
            log.info(f"Misi贸n cargada: {len(wps)} WPs. Home: {wps[0]['lat']:.6f}, {wps[0]['lon']:.6f}")
            return True
    except Exception as e:
        log.error(f"Error cargando misi贸n: {e}")
    return False

@app.route('/api/state/latest', methods=['GET'])
def get_telemetry():
    with state_lock:
        t = state['telemetry']
        active = (time.time() - t['last_update']) < HEARTBEAT_TIMEOUT_S
        return jsonify({
            "ts": time.time(),
            "active": active,
            "lat": t['lat'], "lon": t['lon'], "alt": t['alt'],
            "heading": t['heading'], "yaw": t['heading'],
            "roll": t['roll'], "pitch": t['pitch'],
            "armed": t['armed'], "mode": t['mode']
        })

@app.route('/api/states', methods=['GET'])
def get_states_opensky():
    with state_lock:
        t = state['telemetry']
        now = time.time()
        vehicle_data = [
            "ARDU001", "SITL", "Sim", int(now), int(now),
            t['lon'], t['lat'], t['alt'], not t['armed'],
            t.get('groundspeed', 0), t['heading'], 0, None,
            t.get('alt', 0), None, False, 0
        ]
        payload = { "time": int(now), "states": [vehicle_data] if t['last_update'] > 0 else [] }
        return jsonify(payload)

@app.route('/api/obstacles', methods=['POST'])
def rx_obstacles():
    try:
        data = request.get_json(force=True)
        obs_list = data.get('obstacles', [])
        clean_obs = []
        for o in obs_list:
            clean_obs.append({
                'id': o.get('id', 0),
                'distance': float(o.get('distance', 9999)),
                'lat': o.get('lat'), 'lon': o.get('lon')
            })
        with state_lock:
            state['obstacles'] = clean_obs
            state['last_obstacle_update'] = time.time()
        return jsonify(status="ok")
    except Exception as e:
        return jsonify(error=str(e)), 400

@app.route('/api/status', methods=['GET'])
def status():
    with state_lock:
        return jsonify({
            'mode': state['telemetry']['mode'],
            'wp_idx': state['current_wp_idx'],
            'evasion': state['evasion_active'],
            'obstacles_count': len(state['obstacles'])
        })

def mavlink_loop():
    global master
    conn_str = f"tcp:127.0.0.1:{SITL_TCP_PORT}"
    log.info(f"Conectando MAVLink en {conn_str}...")
    while True:
        try:
            log.info(f"Intentando conectar a {conn_str}...")
            log.debug(f"MAVLink Connection String: {conn_str}") 
            master = mavutil.mavlink_connection(conn_str, source_system=254)
            log.info("MAVLink: Conexi贸n establecida. Esperando Heartbeat...")
            msg = master.wait_heartbeat(timeout=5)
            if msg is None:
                log.warning("Timeout esperando Heartbeat. Reintentando...")
                try: master.close()
                except: pass
                continue
            log.info("MAVLink: Heartbeat recibido. Conectado a ArduPilot!")
            
            params_to_set = {
                b'AHRS_EKF_TYPE': (10, mavutil.mavlink.MAV_PARAM_TYPE_INT8),
                b'ARMING_CHECK': (0, mavutil.mavlink.MAV_PARAM_TYPE_INT32),
                b'FRAME_CLASS': (1, mavutil.mavlink.MAV_PARAM_TYPE_INT8),
                b'FRAME_TYPE': (1, mavutil.mavlink.MAV_PARAM_TYPE_INT8),
            }
            for param_id, (val, type_id) in params_to_set.items():
                master.mav.param_set_send(master.target_system, master.target_component,
                                        param_id, val, type_id)
                time.sleep(0.05)
            
            messages_to_stream = [
                (mavutil.mavlink.MAVLINK_MSG_ID_GLOBAL_POSITION_INT, MAVLINK_INTERVAL_HIGH_US),
                (mavutil.mavlink.MAVLINK_MSG_ID_ATTITUDE, MAVLINK_INTERVAL_HIGH_US),
                (mavutil.mavlink.MAVLINK_MSG_ID_GPS_RAW_INT, MAVLINK_INTERVAL_MED_US),
                (mavutil.mavlink.MAVLINK_MSG_ID_SYS_STATUS, MAVLINK_INTERVAL_LOW_US),
                (mavutil.mavlink.MAVLINK_MSG_ID_VFR_HUD, MAVLINK_INTERVAL_MED_US),
            ]
            for msg_id, interval in messages_to_stream:
                master.mav.command_long_send(master.target_system, master.target_component,
                                            mavutil.mavlink.MAV_CMD_SET_MESSAGE_INTERVAL, 
                                            0, msg_id, interval, 0, 0, 0, 0, 0)

            while True:
                try:
                    msg = master.recv_match(type=['GLOBAL_POSITION_INT', 'ATTITUDE', 'HEARTBEAT', 
                                                'GPS_RAW_INT', 'SYS_STATUS', 'VFR_HUD'], 
                                          blocking=True, timeout=1.0)
                    if not msg: continue
                    time.sleep(0.02)
                    msg_type = msg.get_type()
                    with state_lock:
                        if msg_type == 'GLOBAL_POSITION_INT':
                            state['telemetry']['lat'] = msg.lat / 1e7
                            state['telemetry']['lon'] = msg.lon / 1e7
                            state['telemetry']['alt'] = msg.alt / 1000.0
                            state['telemetry']['heading'] = msg.hdg / 100.0
                            state['telemetry']['last_update'] = time.time()
                        elif msg_type == 'ATTITUDE':
                            state['telemetry']['roll'] = msg.roll * 57.2958
                            state['telemetry']['pitch'] = msg.pitch * 57.2958
                            state['telemetry']['yaw'] = msg.yaw * 57.2958
                        elif msg_type == 'HEARTBEAT':
                            state['telemetry']['mode'] = mavutil.mode_string_v10(msg)
                            state['telemetry']['armed'] = bool(msg.base_mode & mavutil.mavlink.MAV_MODE_FLAG_SAFETY_ARMED)
                        elif msg_type == 'VFR_HUD':
                            state['telemetry']['groundspeed'] = msg.groundspeed
                            state['telemetry']['airspeed'] = msg.airspeed
                            state['telemetry']['heading'] = msg.heading
                        elif msg_type == 'SYS_STATUS':
                            state['telemetry']['voltage'] = msg.voltage_battery / 1000.0
                            state['telemetry']['battery_remaining'] = msg.battery_remaining
                        elif msg_type == 'GPS_RAW_INT':
                            state['telemetry']['gps_fix'] = msg.fix_type
                            state['telemetry']['satellites'] = msg.satellites_visible
                except Exception as e:
                    log.error(f"Error en loop MAVLink: {e}")
                    time.sleep(1.0)
                    break
        except Exception as e:
            log.error(f"Error fatal conectando MAVLink: {e}")
            time.sleep(2)
        try: master.close()
        except: pass
        time.sleep(1)

def control_loop():
    time.sleep(2)
    while True:
        time.sleep(0.1)
        with state_lock:
            tel = state['telemetry'].copy()
            obs = list(state['obstacles'])
            obs_ts = state['last_obstacle_update']
            current_idx = state['current_wp_idx']
            wps = state['waypoints']
            home = state['home']

        if time.time() % 2.0 < 0.15:
            lat = tel.get('lat', 0)
            lon = tel.get('lon', 0)
            alt = tel.get('alt', 0)
            mode = tel.get('mode', 'UNK')
            obs_count = len(obs)
            log.info(f"[STATUS] Mode: {mode} | GPS: {lat:.6f}, {lon:.6f} Alt: {alt:.1f}m | WP: {current_idx} | Obs: {obs_count}")

        if (time.time() - tel['last_update']) > 2.0: continue
            
        if not tel['armed'] and tel['mode'] != 'GUIDED' and current_idx == 1:
             master.set_mode('GUIDED')
             
        if not tel['armed'] and current_idx == 1 and tel['mode'] == 'GUIDED':
            master.arducopter_arm()
            home_alt = home['alt'] if home else 0
            takeoff_alt = (wps[1]['alt'] - home_alt) if len(wps) > 1 else 30.0
            master.mav.command_long_send(master.target_system, master.target_component,
                                         mavutil.mavlink.MAV_CMD_NAV_TAKEOFF, 0, 0, 0, 0, 0, 0, 0, takeoff_alt)
            log.info(f"Iniciando Despegue a {takeoff_alt}m")
            with state_lock: state['takeoff_initiated'] = True
            master.mav.param_set_send(master.target_system, master.target_component, 
                                    b'WPNAV_SPEED', NAV_SPEED_HORIZONTAL_MS*100, mavutil.mavlink.MAV_PARAM_TYPE_REAL32)

        if not tel['armed']: continue

        if current_idx < len(wps) and tel['mode'] not in ['GUIDED', 'LAND', 'RTL', 'AUTO']:
            log.warning(f"[MODE FIX] Detectado {tel['mode']} durante misi贸n. Forzando GUIDED.")
            master.set_mode('GUIDED')

        with state_lock: takeoff_active = state['takeoff_initiated']

        if current_idx == 1 and takeoff_active:
            target_takeoff_alt_msl = wps[1]['alt']
            altitude_diff = abs(tel['alt'] - target_takeoff_alt_msl)
            if altitude_diff < ALTITUDE_TOLERANCE_M:
                log.info(f"[REACHED] WP{current_idx} alcanzado por altitud. Siguiente.")
                with state_lock:
                    state['takeoff_initiated'] = False
                    state['current_wp_idx'] += 1
                continue
            else:
                if time.time() % 2.0 < 0.15:
                    log.info(f"[TAKEOFF] Esperando altitud de despegue: {target_takeoff_alt_msl:.1f}m (Actual: {tel['alt']:.1f}m)")
                continue

        # --- ALGORITMO PORCE (EVASION) ---
        active_path = []
        path_idx = 0
        with state_lock:
            active_path = state['evasion_path']
            path_idx = state['path_index']
            if (time.time() - obs_ts) < OBSTACLE_EXPIRY_S and not active_path:
                nearest_obs = None
                min_dist = float('inf')
                for o in obs:
                    d = o.get('distance', 9999)
                    if d < min_dist: 
                        min_dist = d
                        nearest_obs = o
                
                # --- CAMBIO CLAVE: REACCION_DISTANCE_M ---
                if nearest_obs and min_dist < REACTION_DISTANCE_M:
                    log.warning(f"[PORCE] Obst谩culo detectado a {min_dist:.1f}m. Planificando ruta A*...")
                    target_wp = wps[current_idx] if current_idx < len(wps) else wps[-1]
                    new_route = planner.plan_route(tel['lat'], tel['lon'], target_wp['lat'], target_wp['lon'], obs)
                    if new_route:
                        log.info(f"[PORCE] Ruta generada: {len(new_route)} sub-puntos.")
                        state['evasion_path'] = new_route
                        state['path_index'] = 0
                        state['evasion_active'] = True
                        active_path = new_route
                    else:
                        log.error("[PORCE] A* fall贸. Manteniendo curso (Riesgo de colisi贸n).")

        if active_path:
            if path_idx < len(active_path):
                sub_target = active_path[path_idx]
                dist_sub = haversine(tel['lat'], tel['lon'], sub_target['lat'], sub_target['lon'])
                if dist_sub < 3.0:
                    path_idx += 1
                    with state_lock: state['path_index'] = path_idx
                
                if path_idx < len(active_path):
                    next_pt = active_path[path_idx]
                    target_alt_rel = wps[current_idx]['alt'] - (home['alt'] if home else 0)
                    master.mav.set_position_target_global_int_send(
                        0, master.target_system, master.target_component,
                        mavutil.mavlink.MAV_FRAME_GLOBAL_RELATIVE_ALT_INT,
                        0b0000111111111000,
                        int(next_pt['lat'] * 1e7), int(next_pt['lon'] * 1e7),
                        target_alt_rel,
                        0, 0, 0, 0, 0, 0, 0, 0)
                    if time.time() % 1.0 < 0.1:
                        log.info(f"[PORCE] Navegando Evasi贸n {path_idx+1}/{len(active_path)}")
                    continue
            else:
                log.info("[PORCE] Evasi贸n completada. Retomando misi贸n normal.")
                with state_lock:
                    state['evasion_path'] = []
                    state['evasion_active'] = False

        # --- NAVEGACION ESTANDAR ---
        if current_idx < len(wps):
            target = wps[current_idx]
            dist = haversine(tel['lat'], tel['lon'], target['lat'], target['lon'])
            if dist < WP_TOLERANCE_M:
                log.info(f"[REACHED] WP{current_idx} alcanzado. Siguiente.")
                with state_lock: state['current_wp_idx'] += 1
                continue
            home_alt = home['alt'] if home else 0
            alt_rel = target['alt'] - home_alt
            master.mav.set_position_target_global_int_send(
                0, master.target_system, master.target_component,
                mavutil.mavlink.MAV_FRAME_GLOBAL_RELATIVE_ALT_INT,
                0b0000111111111000,
                int(target['lat']*1e7), int(target['lon']*1e7), alt_rel,
                0,0,0, 0,0,0, 0,0)
            if time.time() % 3.0 < 0.1:
                log.info(f"[NAV] Hacia WP{current_idx} (Dist: {dist:.1f}m)")
        else:
            if tel['mode'] != 'RTL':
                log.info("Misi贸n Terminada. RTL.")
                master.set_mode('RTL')

if __name__ == '__main__':
    if not load_mission():
        log.error("No se pudo cargar la misi贸n. Saliendo.")
        sys.exit(1)
    t_mav = threading.Thread(target=mavlink_loop, daemon=True)
    t_mav.start()
    t_ctrl = threading.Thread(target=control_loop, daemon=True)
    t_ctrl.start()
    log.info(f"Iniciando CEREBRO en puerto {MAVLINK_HUB_HTTP_PORT}...")
    app.run(host='0.0.0.0', port=MAVLINK_HUB_HTTP_PORT, use_reloader=False, threaded=True)
""")